var fs = require('fs'),
	path = require('path'),
	through = require('through2'),
	q = require('q');

var edgeImageDirectory,
	edgeFile,
	imageDictionary = {};

console.log("--------------------------------------------");
function adobeEdgeAnimateSVGFlatten(opts) {

	edgeImageDirectory = opts.imageDirectory + "\\";

	//console.log("---------begin svg flatten  -- +"+edgeImageDirectory+" ----------");

	var stream = through.obj(function (file, enc, callbackStream) {

		var s = this;

		/* Read out the file */
		edgeFile = file.toString( "utf8" );
		//console.log(edgeFile);
		var im = edgeFile.match(/var im=\'images\/\'/);
		//console.log(im);
		//console.log((edgeFile.indexOf("var im = 'images/'") !== -1 ? "pass" : "fail"));
		/* Replace the image directory with the data url string for base64 xml */
		edgeFile = edgeFile.replace(/var im=\'images\/\'/, 'var im=\'\'');
		//console.log(edgeFile);
		/* Get all SVG image names */

		var images = edgeFile.match(/([a-z\-_0-9\/\:\.]*\.(png|jpg|svg|gif|svg))/ig);
		//console.log("iamge = "+images);
		if(images == null){
			return;
		}
		/* Create a get job for each SVG file */
		var imageJobs = [];

		for(var i = 0; i < images.length; i++) {

			imageJobs.push(processImageJob(images[i]));

		}

		/* Execute image jobs */
		q.all(imageJobs).then(function() {

			/* Replace images in the file with their base64 equivalent */
			//var stringImg = 'im+';
			//console.log(imageDictionary);
			for(var x in imageDictionary) {
				//console.log(x);
				if(x.indexOf(".png") !== -1 ) {
					//edgeFile = edgeFile.replace(/\,im\+/, ',\'data:image/png;base64,\'+');
					edgeFile = edgeFile.replace(x, 'data:image/png;base64,' + imageDictionary[x]);

				}
				if(x.indexOf(".gif") !== -1 ) {
					//edgeFile = edgeFile.replace(/\,im\+/, ',\'data:image/gif;base64,\'+');
					edgeFile = edgeFile.replace(x, 'data:image/gif;base64,' +imageDictionary[x]);

				}
				if(x.indexOf(".jpg") !== -1 ) {
					//edgeFile = edgeFile.replace(/\,im\+/, ',\'data:image/jpg;base64,\'+');
					edgeFile = edgeFile.replace(x, 'data:image/jpg;base64,' +imageDictionary[x]);

				}
				if(x.indexOf(".svg") !== -1 ) {
					//edgeFile = edgeFile.replace(/\,im\+/, ',\'data:image/svg+xml;base64,\'+');
					edgeFile = edgeFile.replace(x, 'data:image/svg+xml;base64,' +imageDictionary[x]);

				}

			}

			s.push(edgeFile);

			callbackStream();

		});

	});

	// returning the file stream
	return stream;
};

function processImageJob (image) {

	var deferred = q.defer();

	fs.readFile(edgeImageDirectory + image, 'UTF-8', function(err, data) {
		//console.log("prcess Image "+ edgeImageDirectory + image);
		if (err) {
			//console.log("reding file error "+ err);
			deferred.reject(new Error(err));

		} else {
			//console.log("-0--------------------  "+ edgeImageDirectory + image);
			//console.log(data.toString("utf8"));
			//console.log(edgeImageDirectory + image);
			var bitmap = fs.readFileSync(edgeImageDirectory + image);
			var base64data = new Buffer(bitmap).toString('base64');

			imageDictionary[image] = base64data;

			deferred.resolve(base64data);

		}

	});

	//console.log("return = "+deferred.promise);

	return deferred.promise;

};

module.exports = adobeEdgeAnimateSVGFlatten;
